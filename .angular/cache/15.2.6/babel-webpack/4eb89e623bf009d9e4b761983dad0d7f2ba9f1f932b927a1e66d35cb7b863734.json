{"ast":null,"code":"import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nconst defaultMaxFrame = 750;\nexport class TestScheduler extends VirtualTimeScheduler {\n  constructor(assertDeepEqual) {\n    super(VirtualAction, defaultMaxFrame);\n    this.assertDeepEqual = assertDeepEqual;\n    this.hotObservables = [];\n    this.coldObservables = [];\n    this.flushTests = [];\n    this.runMode = false;\n  }\n  createTime(marbles) {\n    const indexOf = marbles.indexOf('|');\n    if (indexOf === -1) {\n      throw new Error('marble diagram for time should have a completion marker \"|\"');\n    }\n    return indexOf * TestScheduler.frameTimeFactor;\n  }\n  createColdObservable(marbles, values, error) {\n    if (marbles.indexOf('^') !== -1) {\n      throw new Error('cold observable cannot have subscription offset \"^\"');\n    }\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('cold observable cannot have unsubscription marker \"!\"');\n    }\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const cold = new ColdObservable(messages, this);\n    this.coldObservables.push(cold);\n    return cold;\n  }\n  createHotObservable(marbles, values, error) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('hot observable cannot have unsubscription marker \"!\"');\n    }\n    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n    const subject = new HotObservable(messages, this);\n    this.hotObservables.push(subject);\n    return subject;\n  }\n  materializeInnerObservable(observable, outerFrame) {\n    const messages = [];\n    observable.subscribe(value => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createNext(value)\n      });\n    }, err => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createError(err)\n      });\n    }, () => {\n      messages.push({\n        frame: this.frame - outerFrame,\n        notification: Notification.createComplete()\n      });\n    });\n    return messages;\n  }\n  expectObservable(observable, subscriptionMarbles = null) {\n    const actual = [];\n    const flushTest = {\n      actual,\n      ready: false\n    };\n    const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n    const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ? 0 : subscriptionParsed.subscribedFrame;\n    const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n    let subscription;\n    this.schedule(() => {\n      subscription = observable.subscribe(x => {\n        let value = x;\n        if (x instanceof Observable) {\n          value = this.materializeInnerObservable(value, this.frame);\n        }\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createNext(value)\n        });\n      }, err => {\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createError(err)\n        });\n      }, () => {\n        actual.push({\n          frame: this.frame,\n          notification: Notification.createComplete()\n        });\n      });\n    }, subscriptionFrame);\n    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n      this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n    }\n    this.flushTests.push(flushTest);\n    const {\n      runMode\n    } = this;\n    return {\n      toBe(marbles, values, errorValue) {\n        flushTest.ready = true;\n        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n      }\n    };\n  }\n  expectSubscriptions(actualSubscriptionLogs) {\n    const flushTest = {\n      actual: actualSubscriptionLogs,\n      ready: false\n    };\n    this.flushTests.push(flushTest);\n    const {\n      runMode\n    } = this;\n    return {\n      toBe(marbles) {\n        const marblesArray = typeof marbles === 'string' ? [marbles] : marbles;\n        flushTest.ready = true;\n        flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode));\n      }\n    };\n  }\n  flush() {\n    const hotObservables = this.hotObservables;\n    while (hotObservables.length > 0) {\n      hotObservables.shift().setup();\n    }\n    super.flush();\n    this.flushTests = this.flushTests.filter(test => {\n      if (test.ready) {\n        this.assertDeepEqual(test.actual, test.expected);\n        return false;\n      }\n      return true;\n    });\n  }\n  static parseMarblesAsSubscriptions(marbles, runMode = false) {\n    if (typeof marbles !== 'string') {\n      return new SubscriptionLog(Number.POSITIVE_INFINITY);\n    }\n    const len = marbles.length;\n    let groupStart = -1;\n    let subscriptionFrame = Number.POSITIVE_INFINITY;\n    let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n    let frame = 0;\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n      const advanceFrameBy = count => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n      const c = marbles[i];\n      switch (c) {\n        case ' ':\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n          break;\n        case '-':\n          advanceFrameBy(1);\n          break;\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n        case '^':\n          if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n          subscriptionFrame = groupStart > -1 ? groupStart : frame;\n          advanceFrameBy(1);\n          break;\n        case '!':\n          if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n          }\n          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n          break;\n        default:\n          if (runMode && c.match(/^[0-9]$/)) {\n            if (i === 0 || marbles[i - 1] === ' ') {\n              const buffer = marbles.slice(i);\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs;\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n                  default:\n                    break;\n                }\n                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n          throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' + 'subscription marble diagram. Found instead \\'' + c + '\\'.');\n      }\n      frame = nextFrame;\n    }\n    if (unsubscriptionFrame < 0) {\n      return new SubscriptionLog(subscriptionFrame);\n    } else {\n      return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n    }\n  }\n  static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) {\n    if (marbles.indexOf('!') !== -1) {\n      throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n    }\n    const len = marbles.length;\n    const testMessages = [];\n    const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n    let frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n    const getValue = typeof values !== 'object' ? x => x : x => {\n      if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n        return values[x].messages;\n      }\n      return values[x];\n    };\n    let groupStart = -1;\n    for (let i = 0; i < len; i++) {\n      let nextFrame = frame;\n      const advanceFrameBy = count => {\n        nextFrame += count * this.frameTimeFactor;\n      };\n      let notification;\n      const c = marbles[i];\n      switch (c) {\n        case ' ':\n          if (!runMode) {\n            advanceFrameBy(1);\n          }\n          break;\n        case '-':\n          advanceFrameBy(1);\n          break;\n        case '(':\n          groupStart = frame;\n          advanceFrameBy(1);\n          break;\n        case ')':\n          groupStart = -1;\n          advanceFrameBy(1);\n          break;\n        case '|':\n          notification = Notification.createComplete();\n          advanceFrameBy(1);\n          break;\n        case '^':\n          advanceFrameBy(1);\n          break;\n        case '#':\n          notification = Notification.createError(errorValue || 'error');\n          advanceFrameBy(1);\n          break;\n        default:\n          if (runMode && c.match(/^[0-9]$/)) {\n            if (i === 0 || marbles[i - 1] === ' ') {\n              const buffer = marbles.slice(i);\n              const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n              if (match) {\n                i += match[0].length - 1;\n                const duration = parseFloat(match[1]);\n                const unit = match[2];\n                let durationInMs;\n                switch (unit) {\n                  case 'ms':\n                    durationInMs = duration;\n                    break;\n                  case 's':\n                    durationInMs = duration * 1000;\n                    break;\n                  case 'm':\n                    durationInMs = duration * 1000 * 60;\n                    break;\n                  default:\n                    break;\n                }\n                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                break;\n              }\n            }\n          }\n          notification = Notification.createNext(getValue(c));\n          advanceFrameBy(1);\n          break;\n      }\n      if (notification) {\n        testMessages.push({\n          frame: groupStart > -1 ? groupStart : frame,\n          notification\n        });\n      }\n      frame = nextFrame;\n    }\n    return testMessages;\n  }\n  run(callback) {\n    const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n    const prevMaxFrames = this.maxFrames;\n    TestScheduler.frameTimeFactor = 1;\n    this.maxFrames = Number.POSITIVE_INFINITY;\n    this.runMode = true;\n    AsyncScheduler.delegate = this;\n    const helpers = {\n      cold: this.createColdObservable.bind(this),\n      hot: this.createHotObservable.bind(this),\n      flush: this.flush.bind(this),\n      expectObservable: this.expectObservable.bind(this),\n      expectSubscriptions: this.expectSubscriptions.bind(this)\n    };\n    try {\n      const ret = callback(helpers);\n      this.flush();\n      return ret;\n    } finally {\n      TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n      this.maxFrames = prevMaxFrames;\n      this.runMode = false;\n      AsyncScheduler.delegate = undefined;\n    }\n  }\n}","map":{"version":3,"names":["Observable","Notification","ColdObservable","HotObservable","SubscriptionLog","VirtualTimeScheduler","VirtualAction","AsyncScheduler","defaultMaxFrame","TestScheduler","constructor","assertDeepEqual","hotObservables","coldObservables","flushTests","runMode","createTime","marbles","indexOf","Error","frameTimeFactor","createColdObservable","values","error","messages","parseMarbles","undefined","cold","push","createHotObservable","subject","materializeInnerObservable","observable","outerFrame","subscribe","value","frame","notification","createNext","err","createError","createComplete","expectObservable","subscriptionMarbles","actual","flushTest","ready","subscriptionParsed","parseMarblesAsSubscriptions","subscriptionFrame","subscribedFrame","Number","POSITIVE_INFINITY","unsubscriptionFrame","unsubscribedFrame","subscription","schedule","x","unsubscribe","toBe","errorValue","expected","expectSubscriptions","actualSubscriptionLogs","marblesArray","map","flush","length","shift","setup","filter","test","len","groupStart","i","nextFrame","advanceFrameBy","count","c","match","buffer","slice","duration","parseFloat","unit","durationInMs","materializeInnerObservables","testMessages","subIndex","replace","getValue","run","callback","prevFrameTimeFactor","prevMaxFrames","maxFrames","delegate","helpers","bind","hot","ret"],"sources":["/home/anurag/node_modules/rxjs/_esm2015/internal/testing/TestScheduler.js"],"sourcesContent":["import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nconst defaultMaxFrame = 750;\nexport class TestScheduler extends VirtualTimeScheduler {\n    constructor(assertDeepEqual) {\n        super(VirtualAction, defaultMaxFrame);\n        this.assertDeepEqual = assertDeepEqual;\n        this.hotObservables = [];\n        this.coldObservables = [];\n        this.flushTests = [];\n        this.runMode = false;\n    }\n    createTime(marbles) {\n        const indexOf = marbles.indexOf('|');\n        if (indexOf === -1) {\n            throw new Error('marble diagram for time should have a completion marker \"|\"');\n        }\n        return indexOf * TestScheduler.frameTimeFactor;\n    }\n    createColdObservable(marbles, values, error) {\n        if (marbles.indexOf('^') !== -1) {\n            throw new Error('cold observable cannot have subscription offset \"^\"');\n        }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('cold observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n        const cold = new ColdObservable(messages, this);\n        this.coldObservables.push(cold);\n        return cold;\n    }\n    createHotObservable(marbles, values, error) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('hot observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n        const subject = new HotObservable(messages, this);\n        this.hotObservables.push(subject);\n        return subject;\n    }\n    materializeInnerObservable(observable, outerFrame) {\n        const messages = [];\n        observable.subscribe((value) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createNext(value) });\n        }, (err) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createError(err) });\n        }, () => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createComplete() });\n        });\n        return messages;\n    }\n    expectObservable(observable, subscriptionMarbles = null) {\n        const actual = [];\n        const flushTest = { actual, ready: false };\n        const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n        const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ?\n            0 : subscriptionParsed.subscribedFrame;\n        const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n        let subscription;\n        this.schedule(() => {\n            subscription = observable.subscribe(x => {\n                let value = x;\n                if (x instanceof Observable) {\n                    value = this.materializeInnerObservable(value, this.frame);\n                }\n                actual.push({ frame: this.frame, notification: Notification.createNext(value) });\n            }, (err) => {\n                actual.push({ frame: this.frame, notification: Notification.createError(err) });\n            }, () => {\n                actual.push({ frame: this.frame, notification: Notification.createComplete() });\n            });\n        }, subscriptionFrame);\n        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n        }\n        this.flushTests.push(flushTest);\n        const { runMode } = this;\n        return {\n            toBe(marbles, values, errorValue) {\n                flushTest.ready = true;\n                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n            }\n        };\n    }\n    expectSubscriptions(actualSubscriptionLogs) {\n        const flushTest = { actual: actualSubscriptionLogs, ready: false };\n        this.flushTests.push(flushTest);\n        const { runMode } = this;\n        return {\n            toBe(marbles) {\n                const marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                flushTest.ready = true;\n                flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode));\n            }\n        };\n    }\n    flush() {\n        const hotObservables = this.hotObservables;\n        while (hotObservables.length > 0) {\n            hotObservables.shift().setup();\n        }\n        super.flush();\n        this.flushTests = this.flushTests.filter(test => {\n            if (test.ready) {\n                this.assertDeepEqual(test.actual, test.expected);\n                return false;\n            }\n            return true;\n        });\n    }\n    static parseMarblesAsSubscriptions(marbles, runMode = false) {\n        if (typeof marbles !== 'string') {\n            return new SubscriptionLog(Number.POSITIVE_INFINITY);\n        }\n        const len = marbles.length;\n        let groupStart = -1;\n        let subscriptionFrame = Number.POSITIVE_INFINITY;\n        let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n        let frame = 0;\n        for (let i = 0; i < len; i++) {\n            let nextFrame = frame;\n            const advanceFrameBy = (count) => {\n                nextFrame += count * this.frameTimeFactor;\n            };\n            const c = marbles[i];\n            switch (c) {\n                case ' ':\n                    if (!runMode) {\n                        advanceFrameBy(1);\n                    }\n                    break;\n                case '-':\n                    advanceFrameBy(1);\n                    break;\n                case '(':\n                    groupStart = frame;\n                    advanceFrameBy(1);\n                    break;\n                case ')':\n                    groupStart = -1;\n                    advanceFrameBy(1);\n                    break;\n                case '^':\n                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    advanceFrameBy(1);\n                    break;\n                case '!':\n                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                default:\n                    if (runMode && c.match(/^[0-9]$/)) {\n                        if (i === 0 || marbles[i - 1] === ' ') {\n                            const buffer = marbles.slice(i);\n                            const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n                            if (match) {\n                                i += match[0].length - 1;\n                                const duration = parseFloat(match[1]);\n                                const unit = match[2];\n                                let durationInMs;\n                                switch (unit) {\n                                    case 'ms':\n                                        durationInMs = duration;\n                                        break;\n                                    case 's':\n                                        durationInMs = duration * 1000;\n                                        break;\n                                    case 'm':\n                                        durationInMs = duration * 1000 * 60;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                                break;\n                            }\n                        }\n                    }\n                    throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                        'subscription marble diagram. Found instead \\'' + c + '\\'.');\n            }\n            frame = nextFrame;\n        }\n        if (unsubscriptionFrame < 0) {\n            return new SubscriptionLog(subscriptionFrame);\n        }\n        else {\n            return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n        }\n    }\n    static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('conventional marble diagrams cannot have the ' +\n                'unsubscription marker \"!\"');\n        }\n        const len = marbles.length;\n        const testMessages = [];\n        const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n        let frame = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n        const getValue = typeof values !== 'object' ?\n            (x) => x :\n            (x) => {\n                if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n                    return values[x].messages;\n                }\n                return values[x];\n            };\n        let groupStart = -1;\n        for (let i = 0; i < len; i++) {\n            let nextFrame = frame;\n            const advanceFrameBy = (count) => {\n                nextFrame += count * this.frameTimeFactor;\n            };\n            let notification;\n            const c = marbles[i];\n            switch (c) {\n                case ' ':\n                    if (!runMode) {\n                        advanceFrameBy(1);\n                    }\n                    break;\n                case '-':\n                    advanceFrameBy(1);\n                    break;\n                case '(':\n                    groupStart = frame;\n                    advanceFrameBy(1);\n                    break;\n                case ')':\n                    groupStart = -1;\n                    advanceFrameBy(1);\n                    break;\n                case '|':\n                    notification = Notification.createComplete();\n                    advanceFrameBy(1);\n                    break;\n                case '^':\n                    advanceFrameBy(1);\n                    break;\n                case '#':\n                    notification = Notification.createError(errorValue || 'error');\n                    advanceFrameBy(1);\n                    break;\n                default:\n                    if (runMode && c.match(/^[0-9]$/)) {\n                        if (i === 0 || marbles[i - 1] === ' ') {\n                            const buffer = marbles.slice(i);\n                            const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n                            if (match) {\n                                i += match[0].length - 1;\n                                const duration = parseFloat(match[1]);\n                                const unit = match[2];\n                                let durationInMs;\n                                switch (unit) {\n                                    case 'ms':\n                                        durationInMs = duration;\n                                        break;\n                                    case 's':\n                                        durationInMs = duration * 1000;\n                                        break;\n                                    case 'm':\n                                        durationInMs = duration * 1000 * 60;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                                break;\n                            }\n                        }\n                    }\n                    notification = Notification.createNext(getValue(c));\n                    advanceFrameBy(1);\n                    break;\n            }\n            if (notification) {\n                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });\n            }\n            frame = nextFrame;\n        }\n        return testMessages;\n    }\n    run(callback) {\n        const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n        const prevMaxFrames = this.maxFrames;\n        TestScheduler.frameTimeFactor = 1;\n        this.maxFrames = Number.POSITIVE_INFINITY;\n        this.runMode = true;\n        AsyncScheduler.delegate = this;\n        const helpers = {\n            cold: this.createColdObservable.bind(this),\n            hot: this.createHotObservable.bind(this),\n            flush: this.flush.bind(this),\n            expectObservable: this.expectObservable.bind(this),\n            expectSubscriptions: this.expectSubscriptions.bind(this),\n        };\n        try {\n            const ret = callback(helpers);\n            this.flush();\n            return ret;\n        }\n        finally {\n            TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n            this.maxFrames = prevMaxFrames;\n            this.runMode = false;\n            AsyncScheduler.delegate = undefined;\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}